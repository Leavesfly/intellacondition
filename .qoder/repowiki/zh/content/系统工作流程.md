# 系统工作流程

<cite>
**本文档引用的文件**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java)
- [DataFactory.java](file://src/main/java/com/leavesfly/iac/datasource/DataFactory.java)
- [PtTrainer.java](file://src/main/java/com/leavesfly/iac/train/PtTrainer.java)
- [DataCollecter.java](file://src/main/java/com/leavesfly/iac/train/collect/DataCollecter.java)
- [TrainDataSetManager.java](file://src/main/java/com/leavesfly/iac/train/store/TrainDataSetManager.java)
- [PtMultiThreadTrainer.java](file://src/main/java/com/leavesfly/iac/train/trainer/PtMultiThreadTrainer.java)
- [PowerScheduler.java](file://src/main/java/com/leavesfly/iac/execute/PowerScheduler.java)
- [PsoPowerScheduler.java](file://src/main/java/com/leavesfly/iac/execute/scheduler/PsoPowerScheduler.java)
- [Evaluator.java](file://src/main/java/com/leavesfly/iac/evalute/Evaluator.java)
- [PtFitFunc.java](file://src/main/java/com/leavesfly/iac/domain/PtFitFunc.java)
- [PowerVector.java](file://src/main/java/com/leavesfly/iac/domain/PowerVector.java)
- [AppContextConstant.java](file://src/main/java/com/leavesfly/iac/config/AppContextConstant.java)
</cite>

## 目录
1. [简介](#简介)
2. [系统架构概览](#系统架构概览)
3. [训练阶段详细分析](#训练阶段详细分析)
4. [调度阶段详细分析](#调度阶段详细分析)
5. [展示阶段详细分析](#展示阶段详细分析)
6. [DataFactory核心作用](#datafactory核心作用)
7. [数据流分析](#数据流分析)
8. [性能考虑](#性能考虑)
9. [总结](#总结)

## 简介

IntelliAirCondition是一个智能空调仿真平台，通过三个主要阶段实现空调系统的优化调度：训练阶段、调度阶段和展示阶段。该系统采用模块化设计，以DataFactory为核心数据中枢，管理用户、传感器、函数、结果等所有数据的生命周期。

## 系统架构概览

```mermaid
graph TB
subgraph "主程序入口"
Main[IntelliAirCondition.main]
end
subgraph "训练阶段"
TrainPhase[trainPhase]
DataCollect[DataCollecter]
DataSetMgr[TrainDataSetManager]
Trainer[PtMultiThreadTrainer]
FitFunc[PtFitFunc集合]
end
subgraph "调度阶段"
SchedulePhase[schedulePhase]
ThreadPool[线程池]
BaseSolution[基准方案]
PSO[标准PSO调度]
ChaosPSO[混沌PSO调度]
PowerVector[PowerVector]
end
subgraph "展示阶段"
DisplayPhase[displayPhase]
ResultDisp[ResultDisplayer]
EvalResult[EvaluteResult]
end
subgraph "核心数据中枢"
DataFactory[DataFactory单例]
end
Main --> TrainPhase
Main --> SchedulePhase
Main --> DisplayPhase
TrainPhase --> DataCollect
DataCollect --> DataSetMgr
DataSetMgr --> Trainer
Trainer --> FitFunc
FitFunc --> DataFactory
SchedulePhase --> ThreadPool
ThreadPool --> BaseSolution
ThreadPool --> PSO
ThreadPool --> ChaosPSO
BaseSolution --> PowerVector
PSO --> PowerVector
ChaosPSO --> PowerVector
PowerVector --> DataFactory
DisplayPhase --> DataFactory
DataFactory --> EvalResult
EvalResult --> ResultDisp
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L35-L187)
- [DataFactory.java](file://src/main/java/com/leavesfly/iac/datasource/DataFactory.java#L1-L431)

## 训练阶段详细分析

训练阶段是系统的基础，负责建立温度预测模型。该阶段包含四个关键步骤：

### 1. 数据收集阶段

```mermaid
sequenceDiagram
participant Main as IntelliAirCondition
participant DC as DataCollecter
participant DS as DataStore
participant Parser as DomainParser
Main->>DC : getInstance(TRAIN_DATA_FILE_NAME)
DC->>DS : 创建TrainDataSetManagerInLucene
Main->>DC : collectTrainDataItemFromTxt()
loop 从文件读取数据
DC->>DS : collectOneTrainDataItemFromTxt()
DS->>Parser : parseTrainData(line)
Parser-->>DS : IntellacTrainDataItem
end
DS-->>Main : Collection<IntellacTrainDataItem>
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L50-L65)
- [DataCollecter.java](file://src/main/java/com/leavesfly/iac/train/collect/DataCollecter.java#L80-L100)

### 2. 数据存储阶段

训练数据被存储到TrainDataSetManager中，该接口提供了灵活的数据存储和检索能力：

```mermaid
classDiagram
class TrainDataSetManager {
<<interface>>
+fetchTrainDataSetBySensorId(sensorId, outsideTemp) Collection~IntellacTrainDataItem~
+storeTrainDataSet(tarinDataSet) void
}
class TrainDataSetManagerInLucene {
+fetchTrainDataSetBySensorId(sensorId, outsideTemp) Collection~IntellacTrainDataItem~
+storeTrainDataSet(tarinDataSet) void
}
class DataCollecter {
-TrainDataSetManager trainDataSetManager
+collectTrainDataItemFromTxt() Collection~IntellacTrainDataItem~
+getTrainDataSetManager() TrainDataSetManager
}
TrainDataSetManager <|-- TrainDataSetManagerInLucene
DataCollecter --> TrainDataSetManager
```

**图表来源**
- [TrainDataSetManager.java](file://src/main/java/com/leavesfly/iac/train/store/TrainDataSetManager.java#L1-L31)
- [DataCollecter.java](file://src/main/java/com/leavesfly/iac/train/collect/DataCollecter.java#L20-L30)

### 3. 模型训练阶段

系统使用多线程并行训练多个传感器的功率-温度模型：

```mermaid
flowchart TD
Start([开始训练]) --> GetSensorSet["获取传感器ID集合"]
GetSensorSet --> LoopSensor{"遍历每个传感器"}
LoopSensor --> |有传感器| FetchData["获取传感器训练数据"]
FetchData --> SelectModel{"选择训练模型"}
SelectModel --> |BP神经网络| BPTrain["BpTrianTask"]
SelectModel --> |Weka BP| WekaTrain["BpWekaTrianTask"]
SelectModel --> |线性回归| LRTrain["LrTrainTask"]
BPTrain --> SubmitTask["提交训练任务"]
WekaTrain --> SubmitTask
LRTrain --> SubmitTask
SubmitTask --> WaitBarrier["等待所有任务完成"]
WaitBarrier --> CollectResults["收集训练结果"]
CollectResults --> RegisterFitFunc["注册拟合函数"]
RegisterFitFunc --> End([训练完成])
LoopSensor --> |无传感器| WaitBarrier
```

**图表来源**
- [PtMultiThreadTrainer.java](file://src/main/java/com/leavesfly/iac/train/trainer/PtMultiThreadTrainer.java#L50-L90)

### 4. 模型注册阶段

训练完成的PtFitFunc集合被注册到DataFactory中，供后续调度阶段使用：

```mermaid
sequenceDiagram
participant Trainer as PtMultiThreadTrainer
participant Factory as DataFactory
participant FitFunc as PtFitFunc集合
Trainer->>Factory : getInstance()
Trainer->>FitFunc : 创建拟合函数
FitFunc->>Factory : registerFitFunc(fitFuncSet)
Factory->>Factory : 存储到sensorFitFuncSet
Factory->>Factory : 构建sensorFitFuncMap
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L70-L75)
- [DataFactory.java](file://src/main/java/com/leavesfly/iac/datasource/DataFactory.java#L200-L220)

**章节来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L45-L80)
- [DataCollecter.java](file://src/main/java/com/leavesfly/iac/train/collect/DataCollecter.java#L1-L253)
- [PtMultiThreadTrainer.java](file://src/main/java/com/leavesfly/iac/train/trainer/PtMultiThreadTrainer.java#L1-L114)

## 调度阶段详细分析

调度阶段是系统的核心，使用线程池并行执行三种不同的调度算法：

### 1. 线程池架构

```mermaid
graph TB
subgraph "调度阶段线程池"
ThreadPool[ExecutorService]
CountDownLatch[CountDownLatch]
subgraph "任务1：基准方案"
Task1[Runnable 1]
UserTemp[用户期望温度]
Solution1[Solution]
end
subgraph "任务2：标准PSO"
Task2[Runnable 2]
PSOAlgo[标准PSO算法]
PowerVector1[PowerVector]
end
subgraph "任务3：混沌PSO"
Task3[Runnable 3]
ChaosPSO[混沌PSO算法]
PowerVector2[PowerVector]
end
subgraph "公共数据"
DataFactory[DataFactory单例]
EvalResult[EvaluteResult]
end
end
ThreadPool --> Task1
ThreadPool --> Task2
ThreadPool --> Task3
Task1 --> UserTemp
Task1 --> Solution1
Task2 --> PSOAlgo
Task2 --> PowerVector1
Task3 --> ChaosPSO
Task3 --> PowerVector2
Task1 --> DataFactory
Task2 --> DataFactory
Task3 --> DataFactory
DataFactory --> EvalResult
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L85-L130)

### 2. 基准方案执行

基于用户期望温度的解决方案评估：

```mermaid
sequenceDiagram
participant Thread as 线程1
participant Factory as DataFactory
participant Builder as SolutionBuilder
participant Evaluator as Evaluator
participant Result as EvaluteResult
Thread->>Factory : getUserWantTempMap()
loop 遍历用户
Factory-->>Thread : 用户期望温度
Thread->>Builder : buildSolution(userId, temp)
Builder-->>Thread : Solution
Thread->>Evaluator : transform(solution)
Evaluator->>Evaluator : calTotalSatisfaction()
Evaluator->>Evaluator : calTotalPowerCost()
Evaluator-->>Thread : EvaluteResult
Thread->>Factory : addEvaluteResult(result)
end
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L90-L100)

### 3. PSO算法调度

标准PSO和混沌PSO算法的并行执行：

```mermaid
flowchart TD
Start([开始PSO调度]) --> InitParticles["初始化粒子群"]
InitParticles --> CreatePSO["创建PSO算法实例"]
CreatePSO --> RunAlgorithm["运行PSO算法"]
RunAlgorithm --> FindBest["寻找最优解"]
FindBest --> CreatePowerVector["创建PowerVector"]
CreatePowerVector --> BuildSolution["构建Solution"]
BuildSolution --> Evaluate["评估结果"]
Evaluate --> StoreResult["存储评估结果"]
StoreResult --> End([调度完成])
subgraph "PSO算法类型"
StandardPSO[标准PSO]
ChaosPSO[混沌PSO]
end
CreatePSO --> StandardPSO
CreatePSO --> ChaosPSO
```

**图表来源**
- [PsoPowerScheduler.java](file://src/main/java/com/leavesfly/iac/execute/scheduler/PsoPowerScheduler.java#L30-L50)

### 4. PowerVector生成

PowerVector是调度结果的核心数据结构，表示空调设备的功率配置：

```mermaid
classDiagram
class PowerVector {
-PowerValue[] powerValueVector
-int size
+PowerVector(powerValueVector)
+getPowerValueFloatArray() Float[]
+toString() String
}
class PowerValue {
-float value
-PowerRange range
+getValue() float
+setValue(value) void
}
class PowerRange {
-float min
-float max
+PowerRange(min, max)
}
PowerVector --> PowerValue
PowerValue --> PowerRange
```

**图表来源**
- [PowerVector.java](file://src/main/java/com/leavesfly/iac/domain/PowerVector.java#L1-L142)

**章节来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L80-L140)
- [PsoPowerScheduler.java](file://src/main/java/com/leavesfly/iac/execute/scheduler/PsoPowerScheduler.java#L1-L92)

## 展示阶段详细分析

展示阶段负责输出所有评估结果，为用户提供决策支持：

### 1. 结果获取

```mermaid
sequenceDiagram
participant Main as IntelliAirCondition
participant Factory as DataFactory
participant Results as EvaluteResult集合
Main->>Factory : getInstance()
Factory-->>Main : DataFactory单例
Main->>Factory : getEvaluteResultMap()
Factory-->>Main : Map<String, EvaluteResult>
loop 遍历评估结果
Main->>Main : 打印EvaluteResult.toString()
end
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L145-L155)

### 2. 评估结果结构

```mermaid
classDiagram
class EvaluteResult {
-Solution solution
-float satisfaction
-float powerCost
-String solutionName
+getSolutionName() String
+toString() String
}
class Solution {
-String solutionName
-PowerVector powerVector
+getPowerVector() PowerVector
}
class PowerVector {
-PowerValue[] powerValueVector
+getPowerValueFloatArray() Float[]
}
EvaluteResult --> Solution
Solution --> PowerVector
```

**图表来源**
- [Evaluator.java](file://src/main/java/com/leavesfly/iac/evalute/Evaluator.java#L1-L123)

**章节来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L140-L160)

## DataFactory核心作用

DataFactory是整个系统的核心数据中枢，采用单例模式确保全局唯一性：

### 1. 数据管理职责

```mermaid
graph TB
subgraph "DataFactory核心功能"
UserComfort[用户舒适度函数]
UserGeo[用户地理位置]
SensorGeo[传感器地理位置]
FitFunc[温度预测函数]
EvalResult[评估结果]
PowerRange[功率范围约束]
end
subgraph "数据加载"
LoadUser[加载用户舒适度数据]
LoadGeo[加载地理位置数据]
LoadTrain[加载训练数据]
end
subgraph "数据计算"
CalcSensor[计算传感器ID映射]
CalcFunc[计算温度预测函数]
CalcPower[计算功率范围]
end
LoadUser --> UserComfort
LoadGeo --> UserGeo
LoadGeo --> SensorGeo
LoadTrain --> FitFunc
UserComfort --> CalcSensor
UserGeo --> CalcSensor
SensorGeo --> CalcSensor
CalcSensor --> FitFunc
FitFunc --> CalcFunc
CalcFunc --> EvalResult
PowerRange --> CalcPower
CalcPower --> EvalResult
```

**图表来源**
- [DataFactory.java](file://src/main/java/com/leavesfly/iac/datasource/DataFactory.java#L50-L150)

### 2. 单例模式实现

DataFactory使用双重检查锁定机制确保线程安全：

```java
public static DataFactory getInstance() {
    if (dataFactory != null) {
        return dataFactory;
    } else {
        synchronized (DataFactory.class) {
            if (dataFactory == null) {
                dataFactory = new DataFactory();
            }
        }
    }
    return dataFactory;
}
```

### 3. 数据生命周期管理

DataFactory负责管理所有数据的生命周期，包括延迟加载、缓存和同步：

```mermaid
flowchart TD
Request[数据请求] --> CheckCache{"检查缓存"}
CheckCache --> |存在| ReturnCached[返回缓存数据]
CheckCache --> |不存在| LoadData[加载原始数据]
LoadData --> ParseData[解析数据]
ParseData --> CacheData[缓存数据]
CacheData --> ReturnData[返回数据]
ReturnCached --> End([结束])
ReturnData --> End
```

**章节来源**
- [DataFactory.java](file://src/main/java/com/leavesfly/iac/datasource/DataFactory.java#L1-L431)

## 数据流分析

系统中的数据流贯穿三个主要阶段，形成了完整的数据处理管道：

### 1. 数据流向图

```mermaid
graph LR
subgraph "输入层"
UserData[用户数据]
SensorData[传感器数据]
TrainData[训练数据]
end
subgraph "处理层"
Training[训练阶段]
Scheduling[调度阶段]
Evaluation[评估阶段]
end
subgraph "输出层"
Results[评估结果]
Solutions[调度方案]
end
subgraph "共享数据"
DataFactory[DataFactory]
FitFunc[温度预测函数]
PowerVector[功率向量]
end
UserData --> Training
SensorData --> Training
TrainData --> Training
Training --> DataFactory
DataFactory --> FitFunc
FitFunc --> Scheduling
Scheduling --> PowerVector
PowerVector --> Evaluation
Evaluation --> Results
Evaluation --> Solutions
```

### 2. 数据转换过程

```mermaid
sequenceDiagram
participant Input as 输入数据
participant Collector as DataCollecter
participant Manager as TrainDataSetManager
participant Trainer as PtMultiThreadTrainer
participant Factory as DataFactory
participant Scheduler as PowerScheduler
participant Evaluator as Evaluator
participant Output as 输出结果
Input->>Collector : 文本文件数据
Collector->>Manager : IntellacTrainDataItem
Manager->>Trainer : 训练数据集
Trainer->>Factory : PtFitFunc集合
Factory->>Scheduler : 温度预测函数
Scheduler->>Evaluator : PowerVector
Evaluator->>Output : EvaluteResult
```

**图表来源**
- [IntelliAirCondition.java](file://src/main/java/com/leavesfly/iac/IntelliAirCondition.java#L45-L155)

### 3. 数据一致性保证

系统通过以下机制保证数据一致性：

1. **单例模式**：DataFactory确保全局数据的一致性
2. **同步容器**：使用Collections.synchronizedMap保护共享数据
3. **原子操作**：关键数据更新使用原子操作
4. **线程安全**：所有并发访问都经过适当的同步

## 性能考虑

### 1. 并发优化

系统在多个层面实现了并发优化：

- **训练阶段**：使用多线程并行训练多个传感器模型
- **调度阶段**：使用线程池并行执行三种调度算法
- **数据访问**：使用同步容器和原子操作保证线程安全

### 2. 内存管理

- **延迟加载**：按需加载用户舒适度函数和地理位置信息
- **缓存策略**：缓存频繁访问的数据减少重复计算
- **对象复用**：重用PowerVector等对象减少GC压力

### 3. I/O优化

- **批量处理**：一次性读取所有训练数据
- **流式处理**：使用BufferedReader处理大型数据文件
- **异步加载**：使用定时器异步收集实时数据

## 总结

IntelliAirCondition系统通过三个阶段实现了完整的空调调度优化流程：

1. **训练阶段**：从历史数据中学习温度预测模型，建立功率-温度映射关系
2. **调度阶段**：使用多种PSO算法并行搜索最优调度方案
3. **展示阶段**：输出评估结果，为用户提供决策支持

DataFactory作为核心数据中枢，统一管理所有数据的生命周期，确保系统的稳定性和可扩展性。系统采用模块化设计和并发优化，能够高效处理大规模空调调度问题，为智能建筑能源管理提供了有效的解决方案。